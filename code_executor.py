"""
Code Executor Module
Safely executes Python code generated by LLM with error handling
"""
import sys
import io
import traceback
from contextlib import redirect_stdout, redirect_stderr
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt

class CodeExecutor:
    """Executes Python code safely with error capture"""
    
    def __init__(self, context=None):
        """
        Initialize code executor
        
        Args:
            context: Dict of variables available to executed code
        """
        self.context = context or {}
        self.figures = []
        
    def execute(self, code, capture_plots=True):
        """
        Execute Python code and capture output
        
        Args:
            code: Python code string to execute
            capture_plots: Whether to capture matplotlib figures
            
        Returns:
            dict: {
                'success': bool,
                'output': str,
                'error': str,
                'figures': list of matplotlib figures,
                'context': updated context dict
            }
        """
        stdout_buffer = io.StringIO()
        stderr_buffer = io.StringIO()
        
        result = {
            'success': False,
            'output': '',
            'error': '',
            'figures': [],
            'context': self.context.copy()
        }
        
        try:
            # Clear any existing plots
            plt.close('all')
            
            # Execute code with captured output
            with redirect_stdout(stdout_buffer), redirect_stderr(stderr_buffer):
                exec(code, self.context)
            
            # Capture matplotlib figures if requested
            if capture_plots:
                result['figures'] = [
                    plt.figure(num) for num in plt.get_fignums()
                ]
            
            result['success'] = True
            result['output'] = stdout_buffer.getvalue()
            result['context'] = self.context.copy()
            
        except Exception as e:
            result['error'] = f"{type(e).__name__}: {str(e)}\n\n"
            result['error'] += traceback.format_exc()
            result['output'] = stdout_buffer.getvalue()
            
        finally:
            stderr_output = stderr_buffer.getvalue()
            if stderr_output:
                result['output'] += f"\nWarnings:\n{stderr_output}"
        
        return result
    
    def update_context(self, variables):
        """Update execution context with new variables"""
        self.context.update(variables)
    
    def get_variable(self, name):
        """Get variable from execution context"""
        return self.context.get(name)
    
    def clear_context(self):
        """Clear execution context"""
        self.context.clear()
        plt.close('all')
